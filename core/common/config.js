// @ts-check
import { Type } from './constants.js';
import { Events } from './events.js';
import { deepMerge } from './util/datautil.js';

/**
 * Manages config definitions and concrete values.
 */
class Config {
    /**
     * @type {Object<string, ConfigDefinition>}
     */
    #definitions;
    /**
     * @type {Object<string, *>}
     */
    #data;

    constructor() {
        this.#definitions = {};
        this.#data = {};
    }

    /**
     * Defines a new config key with corresponding type, default value and other settings.
     * @param {string} key name of the config key to define
     * @param {string} type see Type in constants.js
     * @param {*} defaultValue the default value of the config option
     * @param {boolean} clientAccessible when true values should be synced to ALL clients and GMs can change them
     * @param {boolean} restartRequired when true clients should be notified of required server restart on changes
     */
    define(key, type, defaultValue, clientAccessible = false, restartRequired = false) {
        if (this.#definitions[key]) throw new Error('Config key ' + key + ' is already defined');

        this.#definitions[key] = {
            type: type,
            defaultValue: defaultValue,
            clientAccessible: clientAccessible,
            restartRequired: restartRequired
        };
    }

    /**
     * Iterates all defined config values and passes them to the provided callback.
     * @param {ConfigIterationCallback} callback the {@link ConfigIterationCallback} callback
     */
    iterate(callback) {
        for (const key of Object.keys(this.#definitions)) {
            callback(key, this.getDefinition(key), this.get(key));
        }
    }

    /**
     * Returns the definition for the provided key.
     * @param {string} key name of the config key
     * @returns {ConfigDefinition} the {@link ConfigDefinition} or null if no definition is present for the provided key
     */
    getDefinition(key) {
        if (this.#definitions[key]) {
            return deepMerge(this.#definitions[key]); // provide a copy to prevent modification
        } else {
            return null;
        }
    }

    /**
     * Returns the current value for the provided key.
     * Behaviour when supplied an undefined key is undefined.
     * @param {string} key name of the config key
     * @returns {*} the current value
     */
    get(key) {
        return this.#data[key] ?? this.#definitions[key].defaultValue;
    }

    /**
     * Sets the current value for the provided key - locally only, no synching is performed automatically
     * @param {string} key name of the config key
     * @param {*} value value to set
     */
    set(key, value) {
        this.#data[key] = value;
        Events.trigger('configValueChange', { key: key, value: value });
    }

    /**
     * "Loads" and stores the provided data.
     * WARNING: This currently performs no validation and should only be supplied with data generated by the save function
     * @param {*} data the data to load
     */
    load(data) {
        this.#data = data ?? {};
    }

    /**
     * "Saves" config data by providing it to the callback
     * @param {ConfigSaveCallback} callback the {@link ConfigSaveCallback} callback to use
     */
    save(callback) {
        callback(this.#data);
    }
}
export const CONFIG = new Config();

//TODO: move this to a better place (extendable by modules)
CONFIG.define('disabledModules', Type.ARRAY, [], false, true);
CONFIG.define('language', Type.STRING, 'de_DE', true, true);
CONFIG.define('gmLockout', Type.BOOLEAN, false, true, false);
CONFIG.define('motd', Type.STRING, '', true, false);


/**
 * Object describing the config definition of a single key
 * @typedef {object} ConfigDefinition
 * @property {string} type the type - see Type in constants.js
 * @property {*} defaultValue the default value of the config option
 * @property {boolean} clientAccessible when true values should be synced to ALL clients and GMs can change them
 * @property {boolean} restartRequired when true clients should be notified of required server restart on changes
 */

/**
 * Callback for the config iteration function
 * @callback ConfigIterationCallback
 * @param {string} key name of the config key to define
 * @param {ConfigDefinition} definition the definition object
 * @param {*} value current value of the config option
 * @returns {void}
 */

/**
 * Callback for handling saving of config data
 * @callback ConfigSaveCallback
 * @param {*} data the config data to save
 * @returns {void}
 */
